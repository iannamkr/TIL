(on writing...)

## 1. Query execution

> 3 layers: 
> logical planning -> physical planning -> execution

### Logical planning 
- logical plan created, analyzed, optimized
- tree representation of query
- abstraction of information about what is supposed to happen
- not contain precise information on how it happens
- composed of
  - relational operators 
    - filter, join, procest ( dataframe transformations )
  - expressions
    - column transformations, filtering conditions, joining conditions
    
## 2. Physical planning
- optimized logical plan
- not understand dataframe / logical plan (LP)
- logical plan has to be converted to a physical plan (PP)
- physical plan
  - bridge between LP and RDDs
  - similarly to logical plan it is a tree
  - contains more specific description of how thins should happen (specific choice of alghorithms)
  - uses lower level primitives - RDDs
  
#### planning - 2 phases

spark plan -> _additional rules_ -> executed plan

- spark plan
  - generated by query planner using strategies
  - for each node in lp
    - e.g) `Join`
  
  - there is a node in pp
    - e.g) `SortMergeJoin`, `BroadcastHashJoin`

- _additional rules_
  - strategy example: Join Selection
  

- executed plan
  - Final version of query plan
  - this will be executed
    - generates RDD code
    ```scala
    df.explain()
    df.queryExecution.sparkPlan
    df.queryExecution.executedPlan
    ```
    
## 3. Spark ui

![image](https://user-images.githubusercontent.com/13671946/79093388-1edfcc00-7d8f-11ea-867f-1b59b1e2aa42.png)


## ref
- Physical Plans in Spark SQL - David Vrba (Socialbakers): https://www.youtube.com/watch?time_continue=1491&v=99fYi2mopbs&feature=emb_logo
